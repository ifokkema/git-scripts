#!/bin/bash

# This is run after a merge (which also happens after a pull merges locally).
# We're looking for remote merges to include in our commit log.

FILEOUT="$(dirname "${0}")/../commits.log";
PROJECT=`basename $(git rev-parse --show-toplevel)`;
BRANCH=`git symbolic-ref --short HEAD 2> /dev/null`;

# Check if we know what this project's last commit was.
STATUS="$(dirname "${0}")/../status.log";
COMMIT=`grep "^${PROJECT} ${BRANCH} " $STATUS | cut -d " " -f 3`;
if [ "${COMMIT}" == "" ];
then
  # We don't have a last commit. Assume we're just pulling in one new merge.
  COMMIT="-1";
else
  # Add ".." to get git log to show all commits since the last one.
  COMMIT=`echo "${COMMIT}.."`;
fi

# Escape $BRANCH if needed.
BRANCH_ESCAPED=$(echo $BRANCH | sed 's/\//\\\//g');

# Now go through last entries and log them all, normal commits or merge commits.
git log --reverse $COMMIT | grep -vE "^(Author|Merge):" \
    | sed "s/^commit/Project: ${PROJECT}\nBranch: ${BRANCH_ESCAPED}\ncommit/" \
    >> $FILEOUT;
echo "" >> $FILEOUT;

# Store the commit hash, so that we won't repeat commits in the logs.
cat $STATUS 2> /dev/null | grep -v "^${PROJECT} ${BRANCH} " > "${STATUS}.tmp";
echo -n "${PROJECT} ${BRANCH} " >> "${STATUS}.tmp";
git rev-parse HEAD >> "${STATUS}.tmp";
mv "${STATUS}.tmp" $STATUS;
